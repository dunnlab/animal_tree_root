---
csl: plos.csl
output:
  pdf_document: default
  github_document: default
  html_document: default
bibliography: manuscript.bib
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
	message = FALSE,
	warning = FALSE,
	echo=FALSE,
	dpi=300,
	cache=FALSE
	)
```


```{r load_data}
	
	# Load data and analysis results generated by 
	# manuscript_kernel.R
	load("manuscript.RData")
```


```{r preliminaries}
library( tidyverse )
library( magrittr )
library( viridis )
library( knitr )
library( gridExtra )

source( "functions.R" )

# A colorblind friendly palette from http://www.cookbook-r.com/Graphs/Colors_(ggplot2)/#a-colorblind-friendly-palette:
cbPalette <- c("#999999", "#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7")

result_colors = c( cbPalette[2], cbPalette[4], cbPalette[1] )
names( result_colors ) = c( "Ctenophora-sister", "Porifera-sister", "Unresolved" )


```

# Rooting the animal tree of life

Casey W. Dunn^1^*, Benjamin Evans^2^, and Yuanning Li^1^

^1^Department of Ecology and Evolutionary Biology, Yale University

^2^Yale Center for Research Computing, Yale University

\* Corresponding author, casey.dunn@yale.edu


## Abstract

## Introduction

Over the past decade there has been considerable debate about the position of the root of the animal phylogeny, with Ctenophora-sister and Porifera-sister (Fig XXOverview) emerging as the two primary hypotheses. Historically, there was little debate about the root of the animal tree of life and Porifera-sister was widely accepted though rarely tested. In contrast to the lack of debate about the position of Porifera, there has long been uncertainty about the relationship of Ctenophora to other animals [@Wallberg:2004ws]. 

The first phylogenomic study to include ctenophores [@Dunn:2008ky] suggested a new hypothesis, now referred to as Ctenophora-sister, that ctenophores are our most distant animal relative. Since then many more studies have been published, some supporting Ctenophora-sister, some Porifera-sister, and some neither. As it has become clear that this is a very difficult phylogenetic challenge, and the problem has become better characterized, it has become an interesting test-case to phylogenetic biologists beyond those concerned with this particular biological problem. Work has been hindered, though, because it has been difficult to directly compare results across studies and synthesize findings to understand the broader patterns of support. Here we synthesize data and results from all previous phylogenomic analyses that tested Ctenophora-sister and Porifera-sister, and reanalyze these data using standardized methods, and perform new analyses to characterize differences between studies. We hope that this provides an integrative overview of the challenge and provides direction for future studies. We also hope that the work we have done here, including consolidating all the datasets in one place with consistent formats and species names, will enhance the technical value of this interesting question to methods-focused investigators that look to develop methods to address difficult phylogenetic problems.


![](figures/Figure_overview.png)
**Fig XXOverview.** (A) The Ctenophora-sister hypothesis posits that there is a clade (designated by the orange node) that includes all animals except Ctenophora, and that Ctenophora is sister to this clade. (B) The Porifera-sister hypothesis posits that there is a clade (designated by the green node) that includes all animals except Porifera, and that Porifera is sister to this clade. Testing these hypotheses requires evaluating the support for each of these alternative nodes. (C) A ctenophore. (D) A sponge.
 

## Variation across studies

### Models of molecular evolution

Models of molecular evolution have several components that each consider different aspects of the evolutionary process. The models that have been used to model protein evolution in studies of the animal root have largely differed according to three components: the exchangeability matrix $E$, the rate of evolution, and the state equilibrium frequencies $\Pi$.

The exchangeability matrix $E$ describes the rate at which one amino acid changes to another. Exchangeability matrices have been used in the studies under consideration here include:

- F81 [@Felsenstein:1981vk] corresponds to equal rates between all states. The F81 matrix is also sometimes referred to as the Poisson matrix. It has no free parameters to estimate since all off-diagonal elements are set to 1.

- WAG [@Whelan:2001ds] is an empirically derived exchangeability matrix based on a dataset of 182 globular protein families. It has no free parameters to estimate since all off-diagonal elements are set according to values estimated from this particular sample dataset.

- LG [@Le:2008fp], like WAG, is an empirically derived exchangeability matrix. It is based on a much larger set of genes, and variation in rates across sites was taken into consideration when it was calculated. It has no free parameters to estimate since all off-diagonal elements are set according to values estimated from this particular sample dataset.

- GTR, the General Time Reversible exchangeability matrix, has free parameters for all off-diagonal elements that describe the exchangeability of different amino acids. It is constrained so that changes are reversible, *i.e.* the rates above the diagonal are the same as those below the diagonal. This leaves 190 parameters that must be estimated from the data long with the other model parameters and the phylogenetic tree topology. This estimation requires a considerable amount of data and computational power, but if successful has the advantage of being based on the dataset at hand rather than a different dataset (as for LG and WAG).

While the exchangeability matrix describes the relative rate of different changes between amino acids, the actual rate can be further scaled. There are couple approaches that have been used in the studies considered here:

- Site homogeneous rates. The rates of evolution are assumed to be the same at all sites in the amino acid alignment.

- Gamma rate heterogeneity. Each site is assigned to a different rate class with its own rate value. This accommodates different rates of evolution across different sites. Gamma is used so commonly that sometimes it isn't even specified, making it difficult at times to know if a study uses Gamma or not.

The vector of equilibrium frequencies $\Pi$ describes the stationary frequency of amino acids. There are a few approaches that have been used across the studies considered here:

- Empirical site homogeneous. The frequency of each amino acid is observed from the matrix under consideration and applied to homogeneously to all sites in the matrix.

- Estimated site homogeneous. The frequency of each amino acid is inferred along with other model parameters, under the assumption that it is the same at all sites.

- CAT site heterogeneous [@Lartillot:2004dq]. Each site is assigned to a class with its own equilibrium frequencies. The number of classes, assignment of sites to classes, and equilibrium frequencies within the data are all estimated in a Bayesian framework.


Models can be assembled by selecting different options for all these different components. The models that are applied in practice area heavily influenced by engineering and computational costs, as well as convention. For example, on the questions considered here F81 and GTR exchangeability matrices have only been used in combination with CAT site heterogeneous models of equilibrium frequency. LG and WAG exchangeability matrices have only been used with site homogeneous estimates of equilibrium frequency. This is further confused by the abbreviations that are used for models. Papers often discuss CAT and WAG models as if they are exclusive, but these particular terms apply to non-exclusive model components-- CAT refers to variation across sites and WAG a particular exchangeability matrix. CAT is generally shorthand for F81+CAT and WAG is shorthand for WAG+homogeneous equilibrium frequency estimation. One could, though, run a WAG+CAT model.

To avoid confusion on this point, we always specify the exchangeability matrix first, followed by modifiers that describe accommodation of heterogeneity in equilibrium frequencies (*e.g.*, CAT) or rate (*e.g.*, Gamma). If there are no modifiers, then it is implied that site homogeneous models are used.

### Gene sampling

### Outgroup taxon sampling

XXX

**Fig XXOutgroup.** The animals and their outgroups, showing the three progressively more inclusive clades Choanimalia, Holozoa, and Opisthokonta.


Choanimalia, Holozoa, Opisthokonta

### Ingroup taxon sampling

Sensitivity to ingroup sampling has received less attention than sensitivity to outgroup sampling. This may be because results have tended to be more sensitive to outgroup sampling.




## Overview of published analyses

### Matrix taxon composition


```{r taxon_rectangles }



taxon_rectangles = lapply(
	sequence_matrices,
	function ( sequence_matrix ){
		clade_rects(sequence_matrix)
	}
) %>%
bind_rows()


clade_colors = viridis( length(clades) )
names( clade_colors ) = clades

ggplot(data=taxon_rectangles) + 
	scale_x_continuous(name="x") + 
	scale_y_continuous(name="y") +
	geom_rect( mapping=aes(xmin=xmin, xmax=xmax, ymin=ymin, ymax=ymax, fill=clade )) + 
	# scale_fill_manual(guide = guide_legend(reverse=TRUE))
	# scale_fill_manual(values = clade_colors, guide = guide_legend(reverse=TRUE))
	scale_fill_discrete(guide = guide_legend(reverse=TRUE)) +
	facet_wrap( ~ manuscript_matrix )

```



XXX

**Fig XXTaxon_composition.** Each of the primary matrices considered here, color coded by taxon sampling. Horizontal size is proportional to the number of genes (XXOr should it be sites?) sampled, vertical size to the number of taxa sampled.

### Matrix gene composition

```{r gene_composition}

busco_overrepresented

ggplot( matrix_summary ) +
	geom_point( aes(x=n_partitions, y=n_busco_partitions, col=manuscript) ) + 
	geom_abline(slope=1,intercept=0) + 
	coord_fixed()

```

**Fig XXBUSCO_annotations.** The number of partitions with BUSCO annotations in each matrix, relative to the number of partitions.


**Fig XXGene_composition.** Each of the primary matrices considered here, color coded by the types of genes sampled (XX Ribosomal proteins, etc). Horizontal size is proportional to the number of genes sampled, vertical size to the number of taxa sampled.

### Matrix overlap

```{r matrix_overlap}

matrix_overlap_rectangles = 
	lapply(sequence_matrices, function(x) lapply(sequence_matrices, function(y) overlap_rects(x,y))) %>% 
	unlist(recursive=FALSE) %>% 
	bind_rows()

ggplot(data=matrix_overlap_rectangles) + 
	scale_x_continuous(name="x") + 
	scale_y_continuous(name="y") +
	geom_rect( mapping=aes(xmin=xmin, xmax=xmax, ymin=ymin, ymax=ymax, fill=MSA ), alpha=0.5) + 
	facet_grid( matrix_1 ~ matrix_2 )

```


**Fig XXAlignment overlap.** Pairwise overlap between each of the primary matrices considered here. Horizontal size is proportional to the number of genes sampled, vertical size to the number of taxa sampled. The horizontal intersection shows the proportions of shared genes, the vertical intersection shows the proportions of shared taxa.


### Support for Porifera-sister and Ctenophora-sister

```{r support_published_analyses}

analyses_published %>% 
	ggplot( aes(x=model_summary, y=clade, col=result, shape=inference) ) +
		geom_jitter( width = 0.20, height = 0.20, alpha=0.7, size=2 ) +
		scale_colour_manual(values = result_colors) +
		theme_classic()

```



A total of `r nrow(analyses_published)` analyses were transcribed from the literature.



## New analyses of published matrices


```{r support_new_analyses}

analyses_new %>% 
	ggplot( aes(x=model_summary, y=clade, col=result, shape=inference) ) +
		geom_jitter( width = 0.20, height = 0.20, alpha=0.7, size=2 ) +
		scale_colour_manual(values = result_colors) +
		theme_classic() + theme(axis.text.x = element_text(angle=45, hjust=1))
```



One of the challenges of interpreting support for the placement of the animal root across studies is that different programs, software versions, and settings have been used across studies, and phylogenetic analysis decisions have been approached in very different ways. Here we reanalyze the primary matrices from each study under consistent conditions with iqtree. We selected this tool because it has greater model flexibility than other tools and is very fast.

We first tested a variety of models for each matrix, and inferred support under the selected model. We then analyzed every matrix under a panel of standard models, including XXX.


```{r modelfinder}

analyses_new %>% 
	filter(modelfinder==TRUE) %>% 
	select( matrix, clade, result, model_summary ) %>%
	kable()

```

Table XXModelfinder. The models selected by modelfinder for each matrix.


### Comparison of iqtree and phylobayes results

Site heterogeneity in equilibrium frequency has been a major concern in tests of Ctenophora-sister and Porifera-sister. This has been addressed with CAT models. iqtree provides a new family of C models that also address site heterogeneity. Given the extensive computational cost and concerns about overparameterization of CAT models, we compared iqtree C results to CAT results for a subset of matrices to see if they give consistent results. This would be of technical interest because it would reduce the cost of accommodating compositional heterogeneity in future analyses.


## New analyses of new matrices

Based on the variation across analyses, we constructed new matrices with altered taxon and gene sampling to test specific hypotheses about differences in support.





## The current state of understanding

### Interpretting variation support

External criteria, eg posterior predictive scores, model fit etc

## Next steps

## Conclusion

## Methods

All files associated with this analysis are available at https://github.com/caseywdunn/animal_root


### Data wrangling

We retreived matrices from each publication (Table XX), storing the raw data in this manuscript's version control repository. We manually edited some minor formatting to make the batch processing of the matrices *en masse*, e.g. standardizing the formatting of charset blocks. All changes made are tracked with git.

### Matrix comparison and annotation

#### Taxon name reconciliation

We programatically queried the NCBI Taxonomy database to standardize names of samples in each matrix. We also use a table where manual entries were needed (Supp Table XX, reconciliation/taxonomy_info/manual_taxonomy_map.tsv), e.g. authors of original matrix indicate species name in original manuscript. For a table summarizing all samples and their new or lengthened names, see Table XX(reconciliation/taxonomy_info/taxon_table.tsv).

#### Sequence Comparisons

Using the partition files for each matrix, we isolated each sequence for each taxon from each partition. Because many of the matrices had been processed by the original authors to remove columns that are poorly sampled or highly variable, these matrix-derived sequences can have deletions relative to the actual gene sequences.

We used DIAMOND [@Buchfink:2014] to compare each sequence to all others using default diamond blastp parameters. We further filtered DIAMOND results such that we retained hits for 90% of partitions (pident > 78.0, eValue < 1e-15, no self->self). We ran BUSCO with default parameters for all sequences against the provided metazoa gene set. We also ran a BLAST+ blastp search against the SwissProt [cite] database, filtering such that we retain at least one hit for ~97% of partitions (pident > 50.0, eValue < 1e-15).

#### Partition Network

We used the sequence similarity comparisons described above to compare partitions. 

We constructed a network with Python and NetworkX [@Hagberg:2008] v2.2 where each node is a partition and each edge represents a DIAMOND sequence-to-sequence match between sequences in the partitions. We extracted each connected component from this network. We further split these components if the the most connected node (i.e. most edges) had two times more the standard deviation from the mean number of edges in the component it is a member of and if removing that node splits the component into two or more components. We then decorated every node in the partition network with the most often found SwissProt BLAST+ result and BUSCO results to see which components contain which classes and families of genes. See Table XX [partition_network_summary table] for a summary tally of each part of the comparison.


### Phylogenetic analyses



## Ackowledgements

We thank the Yale Center for Research Computing for use of the research computing infrastructure, specificaly the Farnam cluser.



## Author contributions




\pagebreak

# Supplemental Information

## Details of published analyses

### Dunn *et al.* 2008

Dunn *et al.* [@Dunn:2008ky] added Expressed Sequence Tag (EST) data for 29 animals. It was the first phylogenomic analysis that included ctenophores, and therefore that could test the relationships of both Ctenophora and Porifera to the rest of animals. It was the first phylogenetic analysis to recover Ctenophora as the sister group to all other animals.

The data matrix was constructed using a semi-automated approach. Genes were translated into proteins, promiscuous domains were masked, all gene sequences from all species were compared to each other with blastp, genes were clustered based on this similarity with TribeMCL [@Enright:2002uq], and these clusters were filtered to remove those with poor taxon sampling and high rates of lineage-specific duplications. Gene trees were then constructed, and in clades of sequences all from the same species all but one sequence were removed (these groups are often due to assembly errors). The remaining gene trees with more than one sequence for any taxon were then manually inspected. If strongly supported deep nodes indicative of paralogy were found, the entire gene was discarded. If the duplications for a a small number of taxa were unresolved, all genes from those taxa were excluded. Genes were then realigned and sites were filtered with Gblocks [@Castresana:2000vy], resulting in a 77 taxon matrix. Some taxa in this matrix were quite unstable, which obscured other strongly-supported relationships. Unstable taxa were identified with leaf stability indices [@Thorley:1999kg], as implemented in phyutility [@Smith:2008gb], and removed from the matrix. This resulted in the 64-taxon matrix that is the focus of most of their analyses. Phylogenetic analyses were conducted under the F81+CAT model in phylobayes [@Lartillot:2004dq], and under the WAG model in MrBayes [@Ronquist:2003hx] and RAxML [@Stamatakis:2006wc].

Regarding the recovery of Ctenophora-sister, the authors concluded:

> The placement of ctenophores (comb jellies) as the sister group to all other sampled metazoans is strongly supported in all our analyses. This result, which has not been postulated before, should be viewed as provisional until more data are considered from placozoans and additional sponges.

Note that there was, in fact, an exception to strong support. An analysis of the 40 ribosomal proteins in the matrix recovered Ctenophora-sister with only 69% support. This study did not include *Trichoplax*.

### Philippe *et al.* 2009

Philippe *et al.* 2009 [Philippe:2009hh]...

### Hejnol et al. 2009



### Pick *et al.* 2010

Pick *et al.* [@Pick:2010eb] sought to test whether Ctenophora-sister was an artefact of insufficient taxon sampling. They added new and additional published sequence data to the 64-taxon matrix of Dunn *et al.* [@Dunn:2008ky]. The new taxa included 12 sponges, 1 ctenophore, 5 cnidarians, and *Trichoplax*. They further modified the matrix by removing 2,150 sites that were poorly sampled or aligned. They considered two different sets of outgroups: Choanoflagellata (resulting in Choanimalia) and the same sampling as Dunn *et al.* (resulting in Opisthokonta).

All their analyses were conducted under the F81+CAT+Gamma model in phylobayes [@Lartillot:2004dq], in both a Bayesian framework and with bootstrapping. All analyses have the same ingroup sampling and site removal so it isn't possible to independently assess the impact of these factors. Analyses with Choanimalia sampling recovered Porifera-sister with 72% posterior probability (PP) and 91% bootstrap support (BS). With broader Opisthokonta sampling, support for Porifera-sister is 84% PP. This is an interesting case where increased outgroup sampling leads to increased support for Porifera-sister.

The authors argue that previous results supporting Ctenophora-sister "are artifacts stemming from insufficient taxon sampling and long-branch attraction (LBA)" and that "this hypothesis should be rejected". Although the posterior probabilities supporting Porifera-sister are not strong, they conclude:

> Results of our analyses indicate that sponges are the sister group to the remaining Metazoa, and Placozoa are sister group to the Bilateria

They also investigated saturation, and conclude that Dunn *et al.* [@Dunn:2008ky] is more saturated than Philippe *et al.* 2009 [Philippe:2009hh]. Note that the Pick *et al.* [@Pick:2010eb] dataset is not reanalyzed here because partition data are not available, and due to site filtering the partition file from Dunn *et al.* [@Dunn:2008ky] cannot be applied to this matrix.


## Model matrix comparison

WAG and LG are both fixed exchange matrices. Their differences are largely limitted to a few amino acid changes.

```{r wagvlg}


# Comparison of LG and WAG matrices

library( tidyverse )
library( magrittr )

# Order in iqtree matrix
aa = c("A", "R", "N", "D", "C", "Q", "E", "G", "H", "I", "L", "K", "M", "F", "P", "S", "T", "W", "Y", "V")

# Functional groups adjacent, from https://en.wikipedia.org/wiki/Amino_acid
aa_functional = c( "R", "H", "K", "D", "E", "S", "T", "N", "Q", "C", "G", "P", "A", "V", "I", "L", "M", "F", "Y", "W" )

triange_to_matrix = function( triangle ){
	R_matrix = rep(NA, 400)
	dim( R_matrix ) = c(20,20)
	

	rownames( R_matrix ) = aa
	colnames( R_matrix ) = aa
	
	# Though iqtree specifies lower triangle, actually in the correct order for upper triangle as this R command reads it
	R_matrix [ upper.tri( R_matrix ) ] = triangle 
	
	# Now fill in the lower half of the matrix
	R_matrix[ is.na(R_matrix) ] = t( R_matrix )[ is.na(R_matrix) ]
	
	# Scale
	R_matrix = R_matrix / mean( R_matrix, na.rm=TRUE )
	
	# Reorder by functional groupings
	R_matrix = R_matrix[, match(aa_functional, colnames(R_matrix) )]
	R_matrix = R_matrix[match(aa_functional, rownames(R_matrix)), ]
	
	R_matrix
}

plot_matrix = function( R_matrix, title=NULL ){
	D = data.frame( R_matrix )
	D$source = row.names(D)
	Dg = gather( D, 1:20, key=dest, value=exch, -source )
	Dg %<>%
		mutate( source=factor(source, levels=aa_functional)  ) %>%
		mutate( dest=factor(dest, levels=aa_functional)  )
	
	Dg %>%
		ggplot(aes(x=dest, y=source)) + 
		geom_tile(aes(fill=exch)) +
		scale_fill_gradient2() +
		ggtitle(title)
}

# Triangle matrices from iqtree source code at https://github.com/Cibiv/IQ-TREE/blob/master/model/modelprotein.cpp

wag_triangle = c(55.15710, 50.98480, 63.53460, 73.89980, 14.73040, 542.94200, 102.70400, 52.81910, 26.52560, 3.02949, 90.85980, 303.55000, 154.36400, 61.67830, 9.88179, 158.28500, 43.91570, 94.71980, 617.41600, 2.13520, 546.94700, 141.67200, 58.46650, 112.55600, 86.55840, 30.66740, 33.00520, 56.77170, 31.69540, 213.71500, 395.62900, 93.06760, 24.89720, 429.41100, 57.00250, 24.94100, 19.33350, 18.69790, 55.42360, 3.94370, 17.01350, 11.39170, 12.73950, 3.04501, 13.81900, 39.79150, 49.76710, 13.15280, 8.48047, 38.42870, 86.94890, 15.42630, 6.13037, 49.94620, 317.09700, 90.62650, 535.14200, 301.20100, 47.98550, 7.40339, 389.49000, 258.44300, 37.35580, 89.04320, 32.38320, 25.75550, 89.34960, 68.31620, 19.82210, 10.37540, 39.04820, 154.52600, 31.51240, 17.41000, 40.41410, 425.74600, 485.40200, 93.42760, 21.04940, 10.27110, 9.61621, 4.67304, 39.80200, 9.99208, 8.11339, 4.99310, 67.93710, 105.94700, 211.51700, 8.88360, 119.06300, 143.85500, 67.94890, 19.50810, 42.39840, 10.94040, 93.33720, 68.23550, 24.35700, 69.61980, 9.99288, 41.58440, 55.68960, 17.13290, 16.14440, 337.07900, 122.41900, 397.42300, 107.17600, 140.76600, 102.88700, 70.49390, 134.18200, 74.01690, 31.94400, 34.47390, 96.71300, 49.39050, 54.59310, 161.32800, 212.11100, 55.44130, 203.00600, 37.48660, 51.29840, 85.79280, 82.27650, 22.58330, 47.33070, 145.81600, 32.66220, 138.69800, 151.61200, 17.19030, 79.53840, 437.80200, 11.31330, 116.39200, 7.19167, 12.97670, 71.70700, 21.57370, 15.65570, 33.69830, 26.25690, 21.24830, 66.53090, 13.75050, 51.57060, 152.96400, 13.94050, 52.37420, 11.08640, 24.07350, 38.15330, 108.60000, 32.57110, 54.38330, 22.77100, 19.63030, 10.36040, 387.34400, 42.01700, 39.86180, 13.32640, 42.84370, 645.42800, 21.60460, 78.69930, 29.11480, 248.53900, 200.60100, 25.18490, 19.62460, 15.23350, 100.21400, 30.12810, 58.87310, 18.72470, 11.83580, 782.13000, 180.03400, 30.54340, 205.84500, 64.98920, 31.48870, 23.27390, 138.82300, 36.53690, 31.47300)
wag_matrix = triange_to_matrix( wag_triangle ) %>% log()

lg_triangle = c(0.425093, 0.276818, 0.751878, 0.395144, 0.123954, 5.076149, 2.489084, 0.534551, 0.528768, 0.062556, 0.969894, 2.807908, 1.695752, 0.523386, 0.084808, 1.038545, 0.363970, 0.541712, 5.243870, 0.003499, 4.128591, 2.066040, 0.390192, 1.437645, 0.844926, 0.569265, 0.267959, 0.348847, 0.358858, 2.426601, 4.509238, 0.927114, 0.640543, 4.813505, 0.423881, 0.311484, 0.149830, 0.126991, 0.191503, 0.010690, 0.320627, 0.072854, 0.044265, 0.008705, 0.108882, 0.395337, 0.301848, 0.068427, 0.015076, 0.594007, 0.582457, 0.069673, 0.044261, 0.366317, 4.145067, 0.536518, 6.326067, 2.145078, 0.282959, 0.013266, 3.234294, 1.807177, 0.296636, 0.697264, 0.159069, 0.137500, 1.124035, 0.484133, 0.371004, 0.025548, 0.893680, 1.672569, 0.173735, 0.139538, 0.442472, 4.273607, 6.312358, 0.656604, 0.253701, 0.052722, 0.089525, 0.017416, 1.105251, 0.035855, 0.018811, 0.089586, 0.682139, 1.112727, 2.592692, 0.023918, 1.798853, 1.177651, 0.332533, 0.161787, 0.394456, 0.075382, 0.624294, 0.419409, 0.196961, 0.508851, 0.078281, 0.249060, 0.390322, 0.099849, 0.094464, 4.727182, 0.858151, 4.008358, 1.240275, 2.784478, 1.223828, 0.611973, 1.739990, 0.990012, 0.064105, 0.182287, 0.748683, 0.346960, 0.361819, 1.338132, 2.139501, 0.578987, 2.000679, 0.425860, 1.143480, 1.080136, 0.604545, 0.129836, 0.584262, 1.033739, 0.302936, 1.136863, 2.020366, 0.165001, 0.571468, 6.472279, 0.180717, 0.593607, 0.045376, 0.029890, 0.670128, 0.236199, 0.077852, 0.268491, 0.597054, 0.111660, 0.619632, 0.049906, 0.696175, 2.457121, 0.095131, 0.248862, 0.140825, 0.218959, 0.314440, 0.612025, 0.135107, 1.165532, 0.257336, 0.120037, 0.054679, 5.306834, 0.232523, 0.299648, 0.131932, 0.481306, 7.803902, 0.089613, 0.400547, 0.245841, 3.151815, 2.547870, 0.170887, 0.083688, 0.037967, 1.959291, 0.210332, 0.245034, 0.076701, 0.119013, 10.649107, 1.702745, 0.185202, 1.898718, 0.654683, 0.296501, 0.098369, 2.188158, 0.189510, 0.249313)
lg_matrix = triange_to_matrix( lg_triangle ) %>% log()



lg_wag_diff = lg_matrix - wag_matrix



lg_wag_diff_thresh =lg_wag_diff
lg_wag_diff_thresh[abs(lg_wag_diff_thresh)<1] = 0


grid.arrange(
	plot_matrix(lg_matrix, title="(A) LG matrix"),
	plot_matrix(wag_matrix, title="(B) WAG matrix"),
	plot_matrix(lg_wag_diff, title="(C) LG - WAG"),
	plot_matrix( lg_wag_diff_thresh, title="(D) Thresholded LG - WAG" )
)

```


## Matrix mapping

Taxa and partition correspondence across manuscripts was assessed by comparing all sequences for each taxon in each partition across all matrices with diamond blast. Based on inspection of sequence similarity, we excluded all comparisons with less than 99% identity and greater than 10^-25^ e-value.


### Taxa comparison across matrices

The primary intent of comparing taxa across matrices was to validate our taxon name reconciliation across studies. 

We first considered pairwise similarity between the same species from different matrices in different studies.






### Partition comparison across matrices


```{r partition_mapping}

# Investigate connected components of genes (ie partitions) that include multiple members fromt he same matrix
clusterstats_within_manuscripts = partition_map_global %>% group_by( matrix, component_number ) %>% summarise(n=n()) %>% arrange(desc(n))
clusterstats = partition_map_global %>% group_by( component_number ) %>% summarise(n=n()) %>% arrange(desc(n))

clusterstats_within_manuscripts %>% print(n=100)
clusterstats %>% print(n=100)
partition_network_summary %>% print()

```

The count for a partition pair can be much arger than the number of genes in the matrix, which suggests that the count is the number of hsps rather than the number of sequences with hits.

There are `r length(unique(partition_network_summary$matrix))` matrices. A gene that is perfectly sampled would form a cluster with this size. Very few clusters, though, are this size. This suggests that intersection of genes between matrices is low





## References
